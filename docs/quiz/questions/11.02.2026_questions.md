# Quiz FastAPI – 11.02.2026

1. **[łatwe]** W aplikacji użytkownik jest tworzony przez endpoint POST. Jak FastAPI rozpoznaje, że dane użytkownika (username, email, password) mają pochodzić z body żądania, a nie z query?
   - A) Na podstawie typu parametru – jeśli to model Pydantic (BaseModel), traktowany jest jako Body
   - B) Na podstawie kolejności parametrów w sygnaturze funkcji
   - C) Trzeba jawnie użyć Body() dla każdego pola
   - D) FastAPI domyślnie traktuje wszystkie parametry jako Body w POST

2. **[łatwe]** Do czego służy `orm_mode = True` w schemacie Pydantic (np. UserDisplay) w tym projekcie?
   - A) Włącza walidację regex na polach modelu
   - B) Umożliwia konwersję z obiektów SQLAlchemy do Pydantic (odczyt atrybutów z ORM)
   - C) Wymusza, aby odpowiedź była w formacie ORM zamiast JSON
   - D) Ustawia tryb tylko do odczytu dla pól schematu

3. **[średnie]** Przy usuwaniu użytkownika (DELETE) logika w db_user zwraca None, gdy użytkownik nie istnieje. Dlaczego w routerze nie zwraca się po prostu tego None do klienta?
   - A) FastAPI nie pozwala zwracać None z endpointu
   - B) Router musi zawsze zwracać słownik z kluczem "message"
   - C) Zwrócenie None dałoby 200 OK z null; lepiej użyć HTTPException (np. 404), żeby klient dostał czytelny błąd i poprawny status HTTP
   - D) Dependency get_db wymaga, aby endpoint zwracał obiekt lub rzucał wyjątek

4. **[trudne]** W konfiguracji bazy SQLite w projekcie używane jest `connect_args={"check_same_thread": False}`. Jaki jest główny powód?
   - A) Aby wyłączyć transakcje i przyspieszyć zapisy
   - B) Aby włączyć tryb tylko do odczytu
   - C) Aby umożliwić równoczesny zapis z wielu procesów
   - D) SQLite domyślnie blokuje użycie połączenia w wielu wątkach; FastAPI może obsługiwać żądania asynchronicznie/w wielu wątkach, więc to ustawienie jest potrzebne

5. **[łatwe]** Jaka jest rola `response_model=UserDisplay` w endpoincie tworzenia użytkownika (POST /user/)?
   - A) Określa format odpowiedzi API – FastAPI serializuje zwrócony obiekt według tego schematu (np. bez hasła)
   - B) Wymusza, aby body żądania było zgodne z UserDisplay
   - C) Ustawia nagłówek Content-Type na application/json
   - D) Włącza walidację odpowiedzi po stronie klienta

6. **[średnie]** W modelu SQLAlchemy artykuł ma kolumnę `user_id = Column(Integer, ForeignKey('users.id'))` oraz `user = relationship('DbUser', back_populates='items')`. Co robi samo ForeignKey?
   - A) Tworzy w Pythonie atrybut article.user do dostępu do użytkownika
   - B) Tworzy w bazie danych klucz obcy i zapewnia integralność referencyjną; relationship służy do dostępu w kodzie
   - C) Automatycznie ładuje użytkownika przy każdym odczycie artykułu
   - D) Zastępuje potrzebę osobnej tabeli użytkowników

7. **[trudne]** Dlaczego w tym projekcie są osobne schematy UserBase (z hasłem) i UserDisplay (bez hasła)?
   - A) UserBase jest szybszy w walidacji niż UserDisplay
   - B) FastAPI wymaga oddzielnych modeli dla metody POST i GET
   - C) UserBase do requestu (walidacja wejścia), UserDisplay do response – żeby hasło nigdy nie było zwracane w odpowiedzi API
   - D) UserDisplay jest używany tylko w Swagger UI

8. **[łatwe]** Funkcja `get_db()` w projekcie używa `yield db` zamiast `return db`. Po co?
   - A) Aby umożliwić asynchroniczne odczyty z bazy
   - B) Aby cache'ować sesję między żądaniami
   - C) yield jest wymagany przez Depends() dla wszystkich dependency
   - D) Aby zwrócić generator; FastAPI po zakończeniu obsługi żądania wywoła kod po yield (np. db.close()), co gwarantuje zamknięcie sesji

9. **[średnie]** Przy aktualizacji użytkownika w db_user zmiany są wprowadzane przez przypisanie pól (np. db_user.username = user.username), a nie przez wywołanie metody update(). Dlaczego?
   - A) Obiekty SQLAlchemy (modele ORM) nie mają metody update(); zmiany robi się przez przypisanie atrybutów, potem commit()
   - B) Metoda update() jest przestarzała w SQLAlchemy 2
   - C) update() wymaga słownika z wszystkimi kolumnami tabeli
   - D) W tym projekcie celowo używany jest tylko raw SQL

10. **[średnie]** W endpoincie GET /user/{id} parametr `id` jest traktowany jako Path. Co by się zmieniło, gdyby ten sam parametr był przekazywany jako query (?id=5)?
   - A) FastAPI nie obsługuje query dla identyfikatorów
   - B) W URL byłoby GET /user?id=5 zamiast GET /user/5; rozpoznanie typu (Path vs Query) zależy od obecności parametru w ścieżce, nie od nazwy
   - C) Walidacja typu int nie działałaby dla query
   - D) Response model musiałby być inny

11. **[trudne]** W endpoincie create_comment (blog_post) w jednym wywołaniu występują: blog (BlogModel), id, comment_id (Path), content (Body), comment_tile (Query), v (Query). Skąd FastAPI wie, skąd brać każdą wartość?
   - A) Z kolejności parametrów w sygnaturze funkcji
   - B) Z nazw parametrów – muszą się zgadzać z nazwami w URL i w body
   - C) Path z fragmentu URL, Query z parametrów query string, Body z body (model lub Body()), niezależnie od kolejności
   - D) Wszystko pochodzi z body JSON, oprócz id i comment_id z URL

12. **[łatwe]** Do czego w tym projekcie służy klasa Hash w db/hash?
   - A) Do szyfrowania całej sesji użytkownika
   - B) Do generowania tokenów JWT
   - C) Do podpisywania plików cookie
   - D) Do hashowania haseł przed zapisem do bazy i do weryfikacji hasła (bcrypt)

13. **[średnie]** Wywołanie `models.Base.metadata.create_all(bind=engine)` w main.py przy starcie aplikacji:
   - A) Tworzy wszystkie tabele zdefiniowane w modelach SQLAlchemy, jeśli nie istnieją; nie aktualizuje istniejących tabel
   - B) Kasuje i na nowo tworzy tabele przy każdym uruchomieniu
   - C) Uruchamia migracje Alembic
   - D) Tworzy tylko tabele użytkowników

14. **[średnie]** Schemat ArticleDisplay zawiera pole `user: User` (zagnieżdżony model). Gdy endpoint GET /article/{id} zwraca obiekt DbArticle z bazy:
   - A) Router musi ręcznie przypisać article.user do obiektu Pydantic User
   - B) Dzięki orm_mode i relacji SQLAlchemy (relationship) FastAPI/Pydantic może zserializować artykuł wraz z zagnieżdżonym użytkownikiem do JSON
   - C) Pole user w ArticleDisplay musi być zawsze None, bo nie ma go w tabeli articles
   - D) Trzeba wywołać osobne zapytanie get_user i wstawić wynik do odpowiedzi

15. **[trudne]** W dokumentacji jest zasada: "routing ważniejszy niż walidacja". Co to oznacza w praktyce?
   - A) Walidacja Path/Query/Body zawsze wykonuje się przed dopasowaniem ścieżki
   - B) Jeśli żądanie nie pasuje do żadnej ścieżki (routing), endpoint nie zostanie wywołany i walidacja parametrów tego endpointu w ogóle się nie wykona
   - C) Walidacja ma wyższy priorytet niż status code odpowiedzi
   - D) Trzeba najpierw zwalidować nagłówki, potem routing

16. **[łatwe]** Router użytkowników jest zarejestrowany z prefix='/user' i tagami ['user']. Co daje tag?
   - A) Zmienia URL endpointów (np. /user/get)
   - B) Włącza autoryzację dla wszystkich endpointów tego routera
   - C) Ustawia domyślny response_model dla wszystkich endpointów
   - D) Grupuje endpointy w dokumentacji Swagger UI; nie wpływa na URL

17. **[średnie]** W logice delete_user najpierw pobierany jest użytkownik, potem jest sprawdzenie `if not db_user: return None`. Dlaczego to sprawdzenie jest konieczne przed db.delete(db_user)?
   - A) Przekazanie None do db.delete() prowadzi do błędu (np. UnmappedInstanceError); zawsze trzeba sprawdzić istnienie obiektu przed usunięciem
   - B) db.delete() wymaga podania typu obiektu, gdy obiekt nie istnieje
   - C) Aby zwrócić 204 No Content zamiast 200
   - D) SQLAlchemy wymaga wywołania db.refresh() przed delete

18. **[średnie]** W relacji między DbUser a DbArticle używane jest back_populates ('items' i 'user'). Do czego służy back_populates?
   - A) Tworzy kolumnę w bazie danych
   - B) Łączy dwie strony relacji w ORM, dzięki czemu można używać user.items i article.user
   - C) Wymusza usuwanie artykułów przy usunięciu użytkownika
   - D) Włącza lazy loading wszystkich artykułów

19. **[trudne]** Dependency Injection przez Depends(required_functionality) w endpoincie get_blogs – skąd pochodzi wartość przekazana do parametru req_parameter?
   - A) Z body żądania
   - B) Z query string
   - C) Z wywołania funkcji required_functionality przez FastAPI przed wykonaniem endpointu; nie pochodzi z Path/Query/Body
   - D) Z nagłówka X-Required-Functionality

20. **[trudne]** Jak w tym projekcie endpoint GET /user/ zwraca listę użytkowników w poprawnym formacie (bez haseł)?
   - A) Router ręcznie usuwa pole password z każdego obiektu przed zwróceniem
   - B) db_user.get_all_users() zwraca już tylko username i email
   - C) Hasła są usuwane w middleware
   - D) Używa response_model=List[UserDisplay]; FastAPI serializuje wyniki według UserDisplay, który nie zawiera hasła
