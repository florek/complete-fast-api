# Quiz FastAPI – 13.02.2026

1. **[łatwe]** Endpoint GET /user/ zwraca listę użytkowników. Skąd klient wie, że odpowiedź nie zawiera pól hasła?
   - A) Funkcja get_all_users zwraca tylko username i email
   - B) Hasła są usuwane w middleware przed wysłaniem
   - C) response_model=List[UserDisplay] powoduje serializację według schematu UserDisplay, który nie zawiera hasła
   - D) Router ręcznie usuwa pole password z każdego obiektu

2. **[łatwe]** Do czego służy prefix w APIRouter(prefix='/user', tags=['user'])?
   - A) Wspólny fragment URL dla wszystkich endpointów tego routera (np. /user/, /user/{id})
   - B) Ustawia domyślny tag w Swagger
   - C) Wymusza autoryzację dla endpointów
   - D) Określa wersję API (v1, v2)

3. **[średnie]** W konfiguracji SQLite w projekcie używane jest connect_args={"check_same_thread": False}. Jaki jest główny powód?
   - A) Aby włączyć tryb tylko do odczytu
   - B) SQLite domyślnie blokuje użycie połączenia w wielu wątkach; przy FastAPI to ustawienie pozwala na współdzielenie silnika między wątkami
   - C) Aby wyłączyć transakcje
   - D) Aby umożliwić zapis z wielu procesów do tego samego pliku

4. **[średnie]** Dlaczego w routerze przy usunięciu użytkownika (DELETE) nie zwraca się po prostu None, gdy logika zwróci None?
   - A) FastAPI nie pozwala zwracać None
   - B) Zwrócenie None dałoby 200 OK z null; lepiej raise HTTPException(404), żeby klient dostał poprawny status i komunikat
   - C) Dependency get_db wymaga wyjątku lub obiektu
   - D) Router musi zawsze zwracać słownik z kluczem "message"

5. **[łatwe]** Co robi orm_mode = True w schemacie Pydantic (np. UserDisplay)?
   - A) Umożliwia konwersję z obiektów SQLAlchemy do Pydantic (odczyt atrybutów z ORM)
   - B) Włącza walidację regex na polach
   - C) Wymusza odpowiedź w formacie ORM
   - D) Ustawia tryb tylko do odczytu

6. **[średnie]** W endpoincie z parametrami: model (Body), id (Path), content (Body), v (Query). Skąd FastAPI wie, skąd brać każdą wartość?
   - A) Z kolejności parametrów w sygnaturze
   - B) Z nazw parametrów – muszą się zgadzać z URL i body
   - C) Path z URL, Query z query string, Body z body (model lub Body()); kontekst decyduje, nie kolejność
   - D) Wszystko oprócz id pochodzi z body JSON

7. **[średnie]** W tym projekcie tworzenie artykułu z treścią zaczynającą się od "Once upon a time" powoduje:
   - A) Zwrócenie 400 Bad Request
   - B) Rzucenie niestandardowego wyjątku (StoryException); zarejestrowany handler zwraca np. 418 z JSON
   - C) Odrzucenie przez walidację Pydantic przed wywołaniem logiki
   - D) Zapis artykułu do bazy z flagą "story"

8. **[trudne]** Funkcja get_db() używa yield db zamiast return db. Dlaczego?
   - A) Aby cache'ować sesję między żądaniami
   - B) yield jest wymagany przez Depends()
   - C) Aby umożliwić asynchroniczne odczyty
   - D) Generator pozwala FastAPI po zakończeniu żądania wykonać kod po yield (np. db.close()), gwarantując zamknięcie sesji

9. **[łatwe]** Jaka jest rola response_model=UserDisplay w endpoincie POST /user/?
   - A) Określa format odpowiedzi – FastAPI serializuje zwrócony obiekt według tego schematu (np. bez hasła)
   - B) Wymusza, aby body żądania było zgodne z UserDisplay
   - C) Ustawia Content-Type na application/json
   - D) Włącza walidację po stronie klienta

10. **[średnie]** W dokumentacji jest zasada: "routing ważniejszy niż walidacja". Co to oznacza?
    - A) Walidacja zawsze wykonuje się przed dopasowaniem ścieżki
    - B) Trzeba najpierw zwalidować nagłówki
    - C) Jeśli żądanie nie pasuje do żadnej ścieżki, endpoint nie zostanie wywołany i walidacja parametrów tego endpointu się nie wykona
    - D) Walidacja ma wyższy priorytet niż status code

11. **[średnie]** Dlaczego w tym projekcie są osobne schematy UserBase (z hasłem) i UserDisplay (bez hasła)?
    - A) UserBase jest szybszy w walidacji
    - B) UserBase do requestu, UserDisplay do response – hasło nigdy nie jest zwracane w odpowiedzi API
    - C) FastAPI wymaga oddzielnych modeli dla POST i GET
    - D) UserDisplay służy tylko w Swagger UI

12. **[trudne]** Wywołanie models.Base.metadata.create_all(bind=engine) przy starcie aplikacji:
    - A) Tworzy tylko tabele użytkowników i artykułów
    - B) Uruchamia migracje Alembic
    - C) Kasuje i na nowo tworzy tabele
    - D) Tworzy wszystkie tabele z modeli SQLAlchemy, jeśli nie istnieją; nie aktualizuje istniejących tabel

13. **[łatwe]** Jak FastAPI rozpoznaje, że dane użytkownika (username, email, password) w POST /user/ mają pochodzić z body?
    - A) Na podstawie typu parametru – model Pydantic (BaseModel) jest traktowany jako Body
    - B) Na podstawie kolejności parametrów
    - C) Trzeba jawnie użyć Body() dla każdego pola
    - D) W POST wszystkie parametry są domyślnie Body

14. **[średnie]** Endpoint GET /product/{id} dla nieistniejącego indeksu (poza zakresem listy produktów) zwraca:
    - A) 200 OK z pustą treścią
    - B) 500 Internal Server Error
    - C) Odpowiedź HTML z pustą stroną
    - D) PlainTextResponse z kodem 404 i komunikatem (np. "Product with id … not found")

15. **[trudne]** Do czego w tym projekcie służy klasa Hash?
    - A) Do szyfrowania sesji
    - B) Do generowania tokenów JWT
    - C) Do hashowania haseł przed zapisem i weryfikacji hasła (bcrypt)
    - D) Do podpisywania cookie

16. **[łatwe]** Co daje tag w APIRouter(prefix='/user', tags=['user'])?
    - A) Zmienia URL (np. /user/get)
    - B) Włącza autoryzację
    - C) Ustawia domyślny response_model
    - D) Grupuje endpointy w dokumentacji Swagger UI; nie wpływa na URL

17. **[trudne]** Schemat ArticleDisplay ma pole user: User (zagnieżdżony). Gdy GET /article/{id} zwraca obiekt DbArticle z bazy:
    - A) Dzięki orm_mode i relationship Pydantic/FastAPI serializują artykuł z zagnieżdżonym user do JSON
    - B) Router musi ręcznie przypisać article.user do obiektu User
    - C) Pole user musi być None
    - D) Trzeba osobno wywołać get_user i wstawić do odpowiedzi

18. **[średnie]** Do czego służy back_populates w relacji między DbUser a DbArticle?
    - A) Tworzy kolumnę w bazie
    - B) Łączy dwie strony relacji w ORM – można używać user.items i article.user
    - C) Wymusza usuwanie artykułów przy usunięciu użytkownika
    - D) Włącza lazy loading

19. **[trudne]** W tym projekcie można zarejestrować własny exception_handler dla niestandardowego wyjątku. Co zwraca taki handler?
    - A) Tylko status code
    - B) Tylko body (string)
    - C) Np. JSONResponse(status_code=..., content={...}) – dowolny kod i treść; wszystkie rzucenia tego wyjątku dają spójną odpowiedź
    - D) Musi zwrócić HTTPException

20. **[trudne]** Przy aktualizacji użytkownika w warstwie db_user zmiany wprowadza się przez przypisanie pól (db_user.username = ...), a nie przez metodę update(). Dlaczego?
    - A) update() jest przestarzała w SQLAlchemy 2
    - B) update() wymaga słownika ze wszystkimi kolumnami
    - C) W projekcie używany jest tylko raw SQL
    - D) Obiekty ORM SQLAlchemy nie mają metody update(); używa się przypisania atrybutów i db.commit()
