# Wynik quizu — 11.02.2026

## Podsumowanie
- **Wynik:** 18/20
- **Procent:** 90%
- **Braki:** brak
- **Najczęstsze kategorie błędów:** średnie (1), trudne (1)
- **Rekomendacje do powtórki:**
  1. Obsługa błędów w FastAPI: kiedy zwracać HTTPException zamiast None (404, 400) i dlaczego to ważne dla kontraktu API.
  2. Konfiguracja SQLite w aplikacjach wielowątkowych: rola `check_same_thread=False` i ograniczenia SQLite przy FastAPI/async.
  3. Zasada „response vs request”: rozróżnienie między zwracaniem wartości a sygnalizowaniem błędu (status HTTP + detail).

## Szczegóły błędów

### Pytanie 3 [średnie]
**Treść:** Przy usuwaniu użytkownika (DELETE) logika w db_user zwraca None, gdy użytkownik nie istnieje. Dlaczego w routerze nie zwraca się po prostu tego None do klienta?

**Twoja odpowiedź:** A (FastAPI nie pozwala zwracać None z endpointu)  
**Poprawna:** C (Zwrócenie None dałoby 200 OK z null; lepiej użyć HTTPException (np. 404), żeby klient dostał czytelny błąd i poprawny status HTTP)

**Komentarz edukacyjny:** FastAPI pozwala zwracać None – wtedy klient dostanie 200 OK z ciałem `null`. To mylące semantycznie: „nie znaleziono” powinno być 404, a nie sukces. Zasada: warstwa routera ma tłumaczyć wyniki logiki biznesowej (None = brak obiektu) na poprawne kody HTTP. Dzięki HTTPException(status_code=404, detail='...') klient wie, że zasób nie istnieje, i może to obsłużyć (np. komunikat, przekierowanie). W projektach API zawsze mapuj „brak wyniku” na 404, a błędy walidacji na 400.

### Pytanie 4 [trudne]
**Treść:** W konfiguracji bazy SQLite w projekcie używane jest `connect_args={"check_same_thread": False}`. Jaki jest główny powód?

**Twoja odpowiedź:** C (Aby umożliwić równoczesny zapis z wielu procesów)  
**Poprawna:** D (SQLite domyślnie blokuje użycie połączenia w wielu wątkach; FastAPI może obsługiwać żądania asynchronicznie/w wielu wątkach, więc to ustawienie jest potrzebne)

**Komentarz edukacyjny:** Chodzi o **wątki**, nie procesy. SQLite domyślnie sprawdza, czy połączenie jest używane tylko w wątku, który je utworzył (`check_same_thread=True`). FastAPI (przez Starlette/uvicorn) może obsługiwać wiele żądań w różnych wątkach; dependency `get_db()` tworzy sesję per request, ale silnik (engine) może być współdzielony. Ustawienie `check_same_thread=False` pozwala na użycie tego samego połączenia/engine z różnych wątków. To nie dotyczy „zapisu z wielu procesów” (różne procesy = osobne połączenia). W produkcji często używa się PostgreSQL/MySQL z pulą połączeń zamiast SQLite.

## Tabela porównawcza

| Nr | Moja | Poprawna | Status |
|----|------|----------|--------|
| 1  | A    | A        | ✅ |
| 2  | B    | B        | ✅ |
| 3  | A    | C        | ❌ |
| 4  | C    | D        | ❌ |
| 5  | A    | A        | ✅ |
| 6  | B    | B        | ✅ |
| 7  | C    | C        | ✅ |
| 8  | D    | D        | ✅ |
| 9  | A    | A        | ✅ |
| 10 | B    | B        | ✅ |
| 11 | C    | C        | ✅ |
| 12 | D    | D        | ✅ |
| 13 | A    | A        | ✅ |
| 14 | B    | B        | ✅ |
| 15 | B    | B        | ✅ |
| 16 | D    | D        | ✅ |
| 17 | A    | A        | ✅ |
| 18 | B    | B        | ✅ |
| 19 | C    | C        | ✅ |
| 20 | D    | D        | ✅ |
