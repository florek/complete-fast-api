# Odpowiedzi do Quizu FastAPI - 08.02.2026

## Odpowiedź 1
**C) Grupuje endpointy w dokumentacji Swagger UI**

`tags` służy tylko do dokumentacji – endpointy z tym samym tagiem są grupowane w Swagger UI / OpenAPI. Nie wpływa na routing ani zachowanie API.

## Odpowiedź 2
**B) `.first()`**

`.first()` wykonuje zapytanie i zwraca pierwszy wynik lub `None`. Używamy go, gdy oczekujemy co najwyżej jednego rekordu (np. po ID). `.all()` zwraca listę, `.one()` rzuca wyjątek przy 0 lub >1 wyniku.

## Odpowiedź 3
**D) Dependency Injection – wstrzyknięcie sesji bazy danych**

`Depends(get_db)` to Dependency Injection w FastAPI. Przed wywołaniem endpointu FastAPI wywołuje `get_db()`, otrzymuje sesję, przekazuje ją do parametru i po zakończeniu requestu zamyka sesję (dzięki yield w get_db).

## Odpowiedź 4
**A) Klucz obcy – powiązanie z inną tabelą**

`ForeignKey('users.id')` definiuje klucz obcy w bazie: wartość w tej kolumnie musi istnieć w `users.id`. Zapewnia integralność referencyjną i powiązanie między tabelami.

## Odpowiedź 5
**D) `raise HTTPException(status_code=404, detail='Not found')`**

W FastAPI błędy HTTP zwracamy przez `raise HTTPException(...)`. Daje to poprawny status i body błędu. Zwracanie `None` lub ustawianie `response.status_code` bez body nie jest zalecane.

## Odpowiedź 6
**A) Nic (tylko dodaje do sesji)**

`db.add(obj)` tylko dodaje obiekt do sesji – nie zapisuje do bazy. Zapis następuje po `db.commit()`. Przed commit nie ma jeszcze ID z bazy (chyba że ustawione ręcznie).

## Odpowiedź 7
**C) Określa format odpowiedzi i serializację do JSON**

`response_model` definiuje schemat odpowiedzi: FastAPI serializuje zwracany obiekt do JSON według tego schematu, filtruje pola i generuje dokumentację OpenAPI.

## Odpowiedź 8
**B) Powiązanie drugiej strony relacji (relacja dwukierunkowa)**

`back_populates` łączy dwie strony relacji: np. `DbUser.items` i `DbArticle.user`. Dzięki temu z obiektu można przejść w obie strony (user → articles, article → user).

## Odpowiedź 9
**D) Path**

Parametr ze ścieżki URL (np. `{id}` w `/user/{id}`) to **Path**. FastAPI rozpoznaje go po tym, że nazwa parametru występuje w ścieżce route’a.

## Odpowiedź 10
**B) Odświeża obiekt danymi z bazy (np. po commit)**

`db.refresh(obj)` ładuje aktualny stan obiektu z bazy (np. wygenerowane ID, wartości domyślne). Przydatne po `commit()`, gdy obiekt mógł się zmienić w bazie.

## Odpowiedź 11
**A) Bezpieczeństwo – nie przechowujemy hasła w plaintext**

Hasła haszujemy (np. bcrypt), żeby przy wycieku bazy nie dało się odczytać haseł. Weryfikacja polega na porównaniu hasha z hashem wpisanego hasła.

## Odpowiedź 12
**C) `field: str = ...` (Ellipsis)**

W Pydantic `...` (Ellipsis) oznacza pole wymagane bez wartości domyślnej. Bez `...` lub wartości domyślnej pole też jest wymagane, ale `= ...` jest jawną konwencją dla „wymagane”.

## Odpowiedź 13
**B) Fabryka sesji ORM – tworzy nowe sesje**

`SessionLocal = sessionmaker(...)` to fabryka sesji. Wywołanie `SessionLocal()` tworzy nową sesję. Każdy request powinien mieć własną sesję (np. przez get_db).

## Odpowiedź 14
**A) 404**

404 Not Found – zasób nie istnieje. 400 to błąd requestu, 401 brak autoryzacji, 500 błąd serwera.

## Odpowiedź 15
**D) Pobieramy obiekt, zmieniamy atrybuty, wywołujemy `db.commit()`**

W SQLAlchemy (ORM) aktualizacja to: pobranie obiektu, zmiana atrybutów, `db.commit()`. Obiekty nie mają metody `.update()` – zmiany są śledzone przez sesję.

## Odpowiedź 16
**B) Mówi FastAPI, że odpowiedź to lista obiektów UserDisplay**

`response_model=List[UserDisplay]` informuje FastAPI, że endpoint zwraca listę i każdy element ma być serializowany według schematu `UserDisplay`.

## Odpowiedź 17
**C) Z `db.database` – klasa bazowa dla modeli SQLAlchemy**

`Base = declarative_base()` jest w `db/database.py`. Wszystkie modele dziedziczą z `Base`, co rejestruje je w SQLAlchemy i pozwala na `create_all()`.

## Odpowiedź 18
**A) Gdy jest typu BaseModel lub opakowany w Body()**

FastAPI traktuje parametr jako Body, gdy ma typ dziedziczący z Pydantic BaseModel lub jest opakowany w `Body(...)`. Reszta (po odjęciu Path, Depends) to Query.

## Odpowiedź 19
**D) Umożliwia użycie jednego połączenia z wielu wątków**

Domyślnie SQLite blokuje użycie połączenia z innego wątku. `check_same_thread=False` wyłącza to sprawdzenie, co jest potrzebne w FastAPI (wiele requestów równolegle). W produkcji lepiej użyć PostgreSQL/MySQL.

## Odpowiedź 20
**C) Opisu zagnieżdżonej struktury JSON (np. relacji)**

Zagnieżdżony model (np. `user: User`) opisuje zagnieżdżony obiekt w JSON – np. relację jeden-do-jednego lub wiele-do-jednego. Dzięki `orm_mode` Pydantic potrafi go zbudować z obiektu SQLAlchemy (relationship).
