# Odpowiedzi do Quizu FastAPI - 05.02.2026

## Odpowiedź 1
**B) Wspólny fragment URL dla wszystkich endpointów w routerze**

`prefix` dodaje wspólny fragment na początku wszystkich ścieżek w routerze. Np. router z `prefix='/blog'` i endpointem `@router.get('/all')` będzie dostępny pod `/blog/all`.

## Odpowiedź 2
**B) Na podstawie kontekstu (obecność w URL, typ BaseModel, etc.)**

FastAPI rozpoznaje typ parametru na podstawie kontekstu:
- `{id}` w URL → Path
- `BaseModel` → Body
- `Depends()` → Dependency
- Reszta → Query

## Odpowiedź 3
**B) `None`**

Metoda `.first()` zwraca pierwszy wynik lub `None`, jeśli nie znaleziono żadnego rekordu. To jest ważne przy sprawdzaniu istnienia obiektu.

## Odpowiedź 4
**B) Aby nie zwracać hasła w odpowiedzi API (bezpieczeństwo)**

`UserBase` zawiera wszystkie pola włącznie z hasłem (dla request), a `UserDisplay` zawiera tylko pola bezpieczne do wyświetlenia (bez hasła). To jest kluczowa zasada bezpieczeństwa.

## Odpowiedź 5
**B) Pozwala na konwersję z obiektów SQLAlchemy do Pydantic**

`orm_mode = True` w konfiguracji Pydantic pozwala na automatyczną konwersję obiektów SQLAlchemy do schematów Pydantic. Bez tego musielibyśmy ręcznie konwertować każdy atrybut.

## Odpowiedź 6
**D) GET, POST, PUT, PATCH, DELETE**

FastAPI obsługuje wszystkie standardowe metody HTTP, w tym:
- **GET** - odczyt danych
- **POST** - tworzenie nowych zasobów
- **PUT** - pełna aktualizacja zasobu
- **PATCH** - częściowa aktualizacja zasobu
- **DELETE** - usunięcie zasobu

FastAPI nie ogranicza się do konkretnych metod - możesz użyć dowolnej metody HTTP. W dekoratorach używamy:
- `@router.get()` - GET
- `@router.post()` - POST
- `@router.put()` - PUT
- `@router.patch()` - PATCH
- `@router.delete()` - DELETE

## Odpowiedź 7
**C) Wystąpi błąd `UnmappedInstanceError`**

Jeśli `db_user` jest `None` i próbujemy wykonać `db.delete(None)`, SQLAlchemy rzuci błąd `UnmappedInstanceError: Class 'builtins.NoneType' is not mapped`. Zawsze musimy sprawdzić istnienie przed operacją.

## Odpowiedź 8
**B) Bezpośrednio przypisujemy wartości do atrybutów obiektu**

Obiekty SQLAlchemy nie mają metody `update()`. Aktualizujemy dane przez bezpośrednie przypisanie:
```python
db_user.username = new_username
db_user.email = new_email
db.commit()
```

## Odpowiedź 9
**B) Hashuje hasło używając algorytmu bcrypt**

`Hash.bcrypt(password)` hashuje hasło używając algorytmu bcrypt z biblioteki `passlib`. To jest bezpieczny sposób przechowywania haseł - nigdy nie przechowujemy haseł w plaintext.

## Odpowiedź 10
**A) Format odpowiedzi będzie zgodny ze schematem `UserDisplay`**

`response_model=UserDisplay` określa format odpowiedzi API. FastAPI automatycznie serializuje dane zgodnie z tym schematem i generuje dokumentację Swagger.

## Odpowiedź 11
**B) Używamy `raise HTTPException(status_code=404, detail='User not found')`**

`HTTPException` to właściwy sposób obsługi błędów w FastAPI. Zwraca odpowiedni kod statusu HTTP (404) i komunikat błędu. Zwracanie `None` dałoby 200 OK z `null`, co jest nieprawidłowe.

## Odpowiedź 12
**A) Odświeża obiekt z bazy danych (pobiera najnowsze dane)**

`db.refresh(db_user)` odświeża obiekt z bazy danych, pobierając najnowsze wartości (np. ID wygenerowane przez bazę). Jest szczególnie przydatne po `commit()`.

## Odpowiedź 13
**B) `add()` dodaje do sesji, `commit()` zapisuje do bazy**

- `db.add()` - dodaje obiekt do sesji SQLAlchemy (jeszcze nie w bazie)
- `db.commit()` - zapisuje wszystkie zmiany z sesji do bazy danych

## Odpowiedź 14
**A) Mechanizm wstrzykiwania zależności (np. sesji bazy danych) jako parametrów**

Dependency Injection w FastAPI pozwala na automatyczne wstrzykiwanie zależności (np. sesji bazy danych) jako parametrów funkcji endpointu. Używamy `Depends(get_db)`.

## Odpowiedź 15
**B) Separacja odpowiedzialności, łatwość testowania, łatwość utrzymania, bezpieczeństwo**

Architektura warstwowa daje wiele korzyści:
- Separacja odpowiedzialności (każda warstwa ma jedno zadanie)
- Łatwość testowania (można testować każdą warstwę osobno)
- Łatwość utrzymania (zmiany w jednej warstwie nie wpływają na inne)
- Bezpieczeństwo (hasła hashowane, nie zwracane)

## Odpowiedź 16
**B) Listę wszystkich obiektów `DbUser`**

`db.query(DbUser).all()` wykonuje zapytanie SELECT * FROM users i zwraca listę wszystkich obiektów `DbUser` z bazy danych.

## Odpowiedź 17
**B) Aby umożliwić użycie SQLite w wielu wątkach (wymagane dla FastAPI)**

SQLite domyślnie blokuje użycie w wielu wątkach. FastAPI działa asynchronicznie, więc potrzebujemy `check_same_thread=False` aby umożliwić współbieżne użycie. W produkcji lepiej użyć PostgreSQL/MySQL.

## Odpowiedź 18
**B) Pole wymagane**

`...` (Ellipsis) w Pydantic oznacza, że pole jest wymagane. Jeśli chcemy pole opcjonalne, używamy `Optional[T]` lub wartości domyślnej.

## Odpowiedź 19
**B) Path, Query, Body, Depends**

W FastAPI mamy 4 główne typy parametrów:
- **Path** - parametry ze ścieżki URL (`{id}`)
- **Query** - parametry z query string (`?page=1`)
- **Body** - dane w ciele żądania (JSON)
- **Depends** - dependency injection

## Odpowiedź 20
**A) Wskazuje, że odpowiedź to lista obiektów `UserDisplay`**

`List[UserDisplay]` jako `response_model` informuje FastAPI, że endpoint zwraca listę obiektów zgodnych ze schematem `UserDisplay`. FastAPI automatycznie serializuje listę obiektów SQLAlchemy do JSON.
